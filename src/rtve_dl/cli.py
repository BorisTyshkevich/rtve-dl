from __future__ import annotations

import argparse
import os
import sys

from rtve_dl.workflows.download import download_selector
from rtve_dl.log import set_debug


def _resolve_env_fallbacks(a: argparse.Namespace, parser: argparse.ArgumentParser) -> None:
    """Resolve env var fallbacks for series_url and series_slug."""
    # series_url: CLI > RTVE_SERIES_URL > error
    if not a.series_url:
        a.series_url = os.environ.get("RTVE_SERIES_URL")
    if not a.series_url:
        parser.error("series_url required (positional arg or RTVE_SERIES_URL env var)")

    # series_slug: CLI > RTVE_SERIES_SLUG > None (derived later)
    if not a.series_slug:
        a.series_slug = os.environ.get("RTVE_SERIES_SLUG")


def _resolve_model_flag(a: argparse.Namespace) -> None:
    """Route unified --model flag to backend-specific option."""
    if a.model:
        if a.translation_backend == "claude":
            a.claude_model = a.model
        else:
            a.codex_model = a.model


def main(argv: list[str] | None = None) -> int:
    if argv is None:
        argv = sys.argv[1:]

    # Strip legacy "download" subcommand for backward compatibility
    if argv and argv[0] == "download":
        argv = argv[1:]

    parser = argparse.ArgumentParser(
        prog="rtve_dl",
        description="Download RTVE videos with multi-language subtitles",
    )

    parser.add_argument(
        "series_url",
        nargs="?",
        default=None,
        help="Series page URL (or set RTVE_SERIES_URL env var)",
    )
    parser.add_argument("selector", help="T7 for a season, or T7S5 for an episode")
    parser.add_argument(
        "-s", "--series-slug",
        default=None,
        help="Override series slug used in data/<slug>/ and tmp/<slug>/ (or set RTVE_SERIES_SLUG env var)",
    )
    parser.add_argument("--quality", default="mp4", choices=["mp4", "best"], help="Prefer progressive MP4 or use best-effort")
    parser.add_argument("-d", "--debug", action="store_true", help="Print progress/stage information")
    parser.add_argument(
        "--asr-if-missing",
        default=True,
        action=argparse.BooleanOptionalAction,
        help="If RTVE has no ES subtitles, generate ES subtitles with ASR backend. Default: enabled.",
    )
    parser.add_argument(
        "--force-asr",
        action="store_true",
        default=False,
        help="Generate ASR subtitles even when RTVE has ES subs, build parallel translations from ASR",
    )
    parser.add_argument(
        "--es-postprocess",
        default=True,
        action=argparse.BooleanOptionalAction,
        help="Run Codex cleanup for Spanish subtitles generated by ASR. Default: enabled.",
    )
    parser.add_argument(
        "--es-postprocess-force",
        action="store_true",
        help="Force Codex cleanup for Spanish subtitles even when source is RTVE VTT.",
    )
    parser.add_argument(
        "--es-postprocess-model",
        default=None,
        help="Override Codex model for ES cleanup stage only (default: use --codex-model).",
    )
    parser.add_argument(
        "--es-postprocess-chunk-cues",
        type=int,
        default=100,
        help="Chunk size for ES cleanup stage (default: 100).",
    )
    parser.add_argument(
        "--asr-backend",
        default="mlx",
        choices=["mlx", "whisperx"],
        help="ASR backend for missing ES subtitles (default: mlx)",
    )
    parser.add_argument(
        "--asr-mlx-model",
        default="mlx-community/whisper-small-mlx",
        help="MLX Whisper model repo (used when --asr-backend mlx)",
    )
    parser.add_argument("--asr-model", default="large-v3", help="WhisperX model for ES subtitle fallback")
    parser.add_argument("--asr-device", default="cpu", help="WhisperX device (default: cpu)")
    parser.add_argument(
        "--asr-compute-type",
        default="float32",
        help="WhisperX compute type (default: float32)",
    )
    parser.add_argument("--asr-batch-size", type=int, default=8, help="WhisperX batch size (default: 8)")
    parser.add_argument(
        "--asr-vad-method",
        default="silero",
        choices=["silero", "pyannote"],
        help="WhisperX VAD method (default: silero)",
    )
    parser.add_argument(
        "--translate-en-if-missing",
        default=True,
        action=argparse.BooleanOptionalAction,
        help="If RTVE doesn't provide English subs, translate ES->EN via Codex. Default: enabled.",
    )
    parser.add_argument(
        "--with-ru",
        default=True,
        action=argparse.BooleanOptionalAction,
        help="Add Russian subtitle track (Codex batch). Default: enabled.",
    )
    parser.add_argument(
        "--require-ru",
        default=True,
        action=argparse.BooleanOptionalAction,
        help="Fail an episode if Russian subtitles could not be generated. Default: enabled.",
    )
    parser.add_argument(
        "--translation-backend",
        default="claude",
        choices=["claude", "codex"],
        help="Translation backend: claude (default) or codex",
    )
    parser.add_argument(
        "--claude-model",
        default="sonnet",
        help="Claude model alias or full name (default: sonnet). Aliases: sonnet, opus",
    )
    parser.add_argument(
        "--codex-model",
        default="gpt-5.1-codex-mini",
        help="Codex model for batch translation when using codex backend (default: gpt-5.1-codex-mini)",
    )
    parser.add_argument(
        "-m", "--model",
        default=None,
        help="Translation model (auto-routes to --claude-model or --codex-model based on backend)",
    )
    parser.add_argument(
        "--codex-chunk-cues",
        type=int,
        default=500,
        help="Chunk size in cues for batch translation (default: 500)",
    )
    parser.add_argument(
        "--no-chunk",
        action="store_true",
        default=False,
        dest="no_chunk",
        help="Send all cues in single request (default for Claude backend)",
    )
    parser.add_argument(
        "--chunked",
        action="store_true",
        default=False,
        dest="force_chunk",
        help="Force chunked mode (default for Codex backend)",
    )
    parser.add_argument(
        "--parallel",
        default=True,
        action=argparse.BooleanOptionalAction,
        help="Enable parallel pipeline (video/subtitles/translation/mux). Default: enabled.",
    )
    parser.add_argument(
        "-j", "--jobs-episodes",
        type=int,
        default=2,
        help="Episode-level parallel workers (season mode). Default: 2",
    )
    parser.add_argument(
        "--jobs-codex-chunks",
        type=int,
        default=4,
        help="Codex chunk workers per translation task. Default: 4",
    )
    parser.add_argument(
        "--subtitle-delay-ms",
        "--delay",
        type=int,
        default=800,
        help=(
            "Subtitle offset in milliseconds applied at MKV mux stage only. "
            "Positive values delay subtitles; negative values make them appear earlier. "
            "Default: 800"
        ),
    )
    parser.add_argument(
        "--subtitle-delay-mode",
        default="manual",
        choices=["manual", "auto"],
        help="Subtitle delay mode. manual uses --subtitle-delay-ms; auto estimates per series.",
    )
    parser.add_argument(
        "--subtitle-delay-auto-scope",
        default="series",
        choices=["series", "episode"],
        help="Auto-delay estimation scope. Default: series",
    )
    parser.add_argument(
        "--subtitle-delay-auto-samples",
        type=int,
        default=3,
        help="Number of local episode samples for auto-delay in series scope. Default: 3",
    )
    parser.add_argument(
        "--subtitle-delay-auto-max-ms",
        type=int,
        default=15000,
        help="Max absolute subtitle delay considered by auto mode. Default: 15000",
    )
    parser.add_argument(
        "--subtitle-delay-auto-refresh",
        action="store_true",
        help="Recompute auto subtitle delay even if cache exists.",
    )
    parser.add_argument(
        "--reset-layer",
        "--reset",
        action="append",
        default=[],
        help=(
            "Reset cache layer(s) before processing selected episodes. "
            "Can be repeated or passed as CSV. "
            "Allowed: subs-es, subs-en, subs-ru, subs-refs, video, mkv, catalog."
        ),
    )

    def _cmd_download(a: argparse.Namespace) -> int:
        set_debug(a.debug)

        # Resolve no_chunk flag
        no_chunk: bool | None = None
        if a.no_chunk and a.force_chunk:
            parser.error("Cannot specify both --no-chunk and --chunked")
        if a.no_chunk:
            no_chunk = True
        elif a.force_chunk:
            no_chunk = False

        return download_selector(
            a.series_url,
            a.selector,
            series_slug=a.series_slug,
            quality=a.quality,
            with_ru=a.with_ru,
            require_ru=a.require_ru,
            translate_en_if_missing=a.translate_en_if_missing,
            asr_if_missing=a.asr_if_missing,
            es_postprocess=a.es_postprocess,
            es_postprocess_force=a.es_postprocess_force,
            es_postprocess_model=a.es_postprocess_model,
            es_postprocess_chunk_cues=a.es_postprocess_chunk_cues,
            force_asr=a.force_asr,
            asr_model=a.asr_model,
            asr_device=a.asr_device,
            asr_compute_type=a.asr_compute_type,
            asr_batch_size=a.asr_batch_size,
            asr_vad_method=a.asr_vad_method,
            asr_backend=a.asr_backend,
            asr_mlx_model=a.asr_mlx_model,
            translation_backend=a.translation_backend,
            claude_model=a.claude_model,
            codex_model=a.codex_model,
            codex_chunk_cues=a.codex_chunk_cues,
            no_chunk=no_chunk,
            subtitle_delay_ms=a.subtitle_delay_ms,
            subtitle_delay_mode=a.subtitle_delay_mode,
            subtitle_delay_auto_scope=a.subtitle_delay_auto_scope,
            subtitle_delay_auto_samples=a.subtitle_delay_auto_samples,
            subtitle_delay_auto_max_ms=a.subtitle_delay_auto_max_ms,
            subtitle_delay_auto_refresh=a.subtitle_delay_auto_refresh,
            parallel=a.parallel,
            jobs_episodes=a.jobs_episodes,
            jobs_codex_chunks=a.jobs_codex_chunks,
            reset_layers=a.reset_layer,
        )

    args = parser.parse_args(argv)

    # Resolve env var fallbacks and unified model flag
    _resolve_env_fallbacks(args, parser)
    _resolve_model_flag(args)

    try:
        return _cmd_download(args)
    except RuntimeError as e:
        if getattr(args, "debug", False):
            raise
        print(f"error: {e}", file=sys.stderr)
        return 1
    except KeyboardInterrupt:
        print("\ninterrupted", file=sys.stderr)
        return 130


if __name__ == "__main__":
    raise SystemExit(main())
